#include <inttypes.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h>
#include "lcd.h"

#define F_CPU 20000000

// #define FOSC 20000000 // Clock Speed
// #define BAUD 2400
// #define MYUBRR FOSC/16/BAUD-1

#define MAXN 256 // Количество отсчётов
#define PICKS 6  // Количество амплитудных пиков

//volatile unsigned char ADCBUF[MAXN * 2];

// Частотное разрешение
const float f_step = 2e7 / (256 * (76 + 1)) / MAXN;

// Поворотные коэффициенты для БПФ
const float cfs[MAXN] = {
    1, -0, 0.999699, -0.0245412, 0.998795, -0.0490677, 0.99729, -0.0735646,
    0.995185, -0.0980171, 0.99248, -0.122411, 0.989177, -0.14673, 0.985278, -0.170962,
    0.980785, -0.19509, 0.975702, -0.219101, 0.970031, -0.24298, 0.963776, -0.266713,
    0.95694, -0.290285, 0.949528, -0.313682, 0.941544, -0.33689, 0.932993, -0.359895,
    0.92388, -0.382683, 0.91421, -0.405241, 0.903989, -0.427555, 0.893224, -0.449611,
    0.881921, -0.471397, 0.870087, -0.492898, 0.857729, -0.514103, 0.844854, -0.534998,
    0.83147, -0.55557, 0.817585, -0.575808, 0.803208, -0.595699, 0.788346, -0.615232,
    0.77301, -0.634393, 0.757209, -0.653173, 0.740951, -0.671559, 0.724247, -0.689541,
    0.707107, -0.707107, 0.689541, -0.724247, 0.671559, -0.740951, 0.653173, -0.757209,
    0.634393, -0.77301, 0.615232, -0.788346, 0.595699, -0.803208, 0.575808, -0.817585,
    0.55557, -0.83147, 0.534998, -0.844854, 0.514103, -0.857729, 0.492898, -0.870087,
    0.471397, -0.881921, 0.449611, -0.893224, 0.427555, -0.903989, 0.405241, -0.91421,
    0.382683, -0.92388, 0.359895, -0.932993, 0.33689, -0.941544, 0.313682, -0.949528,
    0.290285, -0.95694, 0.266713, -0.963776, 0.24298, -0.970031, 0.219101, -0.975702,
    0.19509, -0.980785, 0.170962, -0.985278, 0.14673, -0.989177, 0.122411, -0.99248,
    0.0980171, -0.995185, 0.0735646, -0.99729, 0.0490677, -0.998795, 0.0245412, -0.999699,
    6.12303e-17, -1, -0.0245412, -0.999699, -0.0490677, -0.998795, -0.0735646, -0.99729,
    -0.0980171, -0.995185, -0.122411, -0.99248, -0.14673, -0.989177, -0.170962, -0.985278,
    -0.19509, -0.980785, -0.219101, -0.975702, -0.24298, -0.970031, -0.266713, -0.963776,
    -0.290285, -0.95694, -0.313682, -0.949528, -0.33689, -0.941544, -0.359895, -0.932993,
    -0.382683, -0.92388, -0.405241, -0.91421, -0.427555, -0.903989, -0.449611, -0.893224,
    -0.471397, -0.881921, -0.492898, -0.870087, -0.514103, -0.857729, -0.534998, -0.844854,
    -0.55557, -0.83147, -0.575808, -0.817585, -0.595699, -0.803208, -0.615232, -0.788346,
    -0.634393, -0.77301, -0.653173, -0.757209, -0.671559, -0.740951, -0.689541, -0.724247,
    -0.707107, -0.707107, -0.724247, -0.689541, -0.740951, -0.671559, -0.757209, -0.653173,
    -0.77301, -0.634393, -0.788346, -0.615232, -0.803208, -0.595699, -0.817585, -0.575808,
    -0.83147, -0.55557, -0.844854, -0.534998, -0.857729, -0.514103, -0.870087, -0.492898,
    -0.881921, -0.471397, -0.893224, -0.449611, -0.903989, -0.427555, -0.91421, -0.405241,
    -0.92388, -0.382683, -0.932993, -0.359895, -0.941544, -0.33689, -0.949528, -0.313682,
    -0.95694, -0.290285, -0.963776, -0.266713, -0.970031, -0.24298, -0.975702, -0.219101,
    -0.980785, -0.19509, -0.985278, -0.170962, -0.989177, -0.14673, -0.99248, -0.122411,
    -0.995185, -0.0980171, -0.99729, -0.0735646, -0.998795, -0.0490677, -0.999699, -0.0245412
};

// Оконная функция в точках от 0 до 255
const float window[MAXN] = {
    0.07672, 0.0768601, 0.0772804, 0.0779807,
    0.0789604, 0.080219, 0.0817557, 0.0835697,
    0.0856598, 0.0880247, 0.0906629, 0.093573,
    0.0967531, 0.100201, 0.103916, 0.107894,
    0.112133, 0.116631, 0.121385, 0.126392,
    0.13165, 0.137154, 0.142902, 0.148889,
    0.155114, 0.161571, 0.168257, 0.175167,
    0.182298, 0.189645, 0.197204, 0.20497,
    0.212938, 0.221104, 0.229463, 0.238009,
    0.246737, 0.255642, 0.264719, 0.273963,
    0.283366, 0.292925, 0.302632, 0.312483,
    0.322471, 0.332589, 0.342833, 0.353195,
    0.36367, 0.374251, 0.384932, 0.395705,
    0.406566, 0.417506, 0.42852, 0.4396,
    0.45074, 0.461934, 0.473174, 0.484453,
    0.495765, 0.507103, 0.51846, 0.529829,
    0.541204, 0.552576, 0.56394, 0.575289,
    0.586615, 0.597911, 0.609172, 0.620389,
    0.631557, 0.642668, 0.653716, 0.664694,
    0.675595, 0.686413, 0.697141, 0.707772,
    0.718301, 0.72872, 0.739024, 0.749206,
    0.75926, 0.76918, 0.77896, 0.788594,
    0.798075, 0.807399, 0.81656, 0.825552,
    0.83437, 0.843008, 0.85146, 0.859723,
    0.867791, 0.875659, 0.883322, 0.890775,
    0.898015, 0.905036, 0.911835, 0.918406,
    0.924748, 0.930854, 0.936723, 0.942349,
    0.94773, 0.952863, 0.957744, 0.96237,
    0.966739, 0.970848, 0.974695, 0.978276,
    0.981591, 0.984636, 0.98741, 0.989912,
    0.99214, 0.994092, 0.995767, 0.997165,
    0.998284, 0.999124, 0.999685, 0.999965,
    0.999965, 0.999685, 0.999124, 0.998284,
    0.997165, 0.995767, 0.994092, 0.99214,
    0.989912, 0.98741, 0.984636, 0.981591,
    0.978276, 0.974695, 0.970848, 0.966739,
    0.96237, 0.957744, 0.952863, 0.94773,
    0.942349, 0.936723, 0.930854, 0.924748,
    0.918406, 0.911835, 0.905036, 0.898015,
    0.890775, 0.883322, 0.875659, 0.867791,
    0.859723, 0.85146, 0.843008, 0.83437,
    0.825552, 0.81656, 0.807399, 0.798075,
    0.788594, 0.77896, 0.76918, 0.75926,
    0.749206, 0.739024, 0.72872, 0.718301,
    0.707772, 0.697141, 0.686413, 0.675595,
    0.664694, 0.653716, 0.642668, 0.631557,
    0.620389, 0.609172, 0.597911, 0.586615,
    0.575289, 0.56394, 0.552576, 0.541204,
    0.529829, 0.51846, 0.507103, 0.495765,
    0.484453, 0.473174, 0.461934, 0.45074,
    0.4396, 0.42852, 0.417506, 0.406566,
    0.395705, 0.384932, 0.374251, 0.36367,
    0.353195, 0.342833, 0.332589, 0.322471,
    0.312483, 0.302632, 0.292925, 0.283366,
    0.273963, 0.264719, 0.255642, 0.246737,
    0.238009, 0.229463, 0.221104, 0.212938,
    0.20497, 0.197204, 0.189645, 0.182298,
    0.175167, 0.168257, 0.161571, 0.155114,
    0.148889, 0.142902, 0.137154, 0.13165,
    0.126392, 0.121385, 0.116631, 0.112133,
    0.107894, 0.103916, 0.100201, 0.0967531,
    0.093573, 0.0906629, 0.0880247, 0.0856598,
    0.0835697, 0.0817557, 0.080219, 0.0789604,
    0.0779807, 0.0772804, 0.0768601, 0.07672
};

// Позиции, в которые нужно записывать элементы для БПФ для экономии памяти
const short pos[MAXN] = {
    0x0, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x8, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x4, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0xc, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x2, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0xa, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x6, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0xe, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x1, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x9, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x5, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0xd, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x3, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0xb, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x7, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0xf, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};

/*
   Для каждой частоты спектра от 0-й до 127-й по два номера:
    номер ближайшей ноты слева и ближайшей ноты справа по спектру.
*/
const signed char tones[MAXN] = {
    0xff, 0x4, 0xff, 0x4, 0xff, 0x4, 0xff, 0x4,
    0xff, 0x4, 0xff, 0x4, 0x6, 0x7, 0x9, 0xa,
    0xb, 0x0, 0x1, 0x2, 0x3, 0x4, 0x4, 0x5,
    0x6, 0x7, 0x7, 0x8, 0x9, 0xa, 0xa, 0xb,
    0xb, 0x0, 0x0, 0x1, 0x1, 0x2, 0x2, 0x3,
    0x3, 0x4, 0x4, 0x5, 0x4, 0x5, 0x5, 0x6,
    0x6, 0x7, 0x7, 0x8, 0x7, 0x8, 0x8, 0x9,
    0x9, 0xa, 0x9, 0xa, 0xa, 0xb, 0xa, 0xb,
    0xb, 0x0, 0xb, 0x0, 0x0, 0x1, 0x1, 0x2,
    0x1, 0x2, 0x1, 0x2, 0x2, 0x3, 0x2, 0x3,
    0x3, 0x4, 0x3, 0x4, 0x4, 0x5, 0x4, 0x5,
    0x4, 0x5, 0x5, 0x6, 0x5, 0x6, 0x6, 0x7,
    0x6, 0x7, 0x6, 0x7, 0x7, 0x8, 0x7, 0x8,
    0x7, 0x8, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9,
    0x9, 0xa, 0x9, 0xa, 0x9, 0xa, 0xa, 0xb,
    0xa, 0xb, 0xa, 0xb, 0xa, 0xb, 0xb, 0x0,
    0xb, 0x0, 0xb, 0x0, 0xb, 0x0, 0x0, 0x1,
    0x0, 0x1, 0x0, 0x1, 0x1, 0x2, 0x1, 0x2,
    0x1, 0x2, 0x1, 0x2, 0x1, 0x2, 0x2, 0x3,
    0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x3, 0x4,
    0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4,
    0x4, 0x5, 0x4, 0x5, 0x4, 0x5, 0x4, 0x5,
    0x4, 0x5, 0x5, 0x6, 0x5, 0x6, 0x5, 0x6,
    0x5, 0x6, 0x5, 0x6, 0x6, 0x7, 0x6, 0x7,
    0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0x7, 0x8,
    0x7, 0x8, 0x7, 0x8, 0x7, 0x8, 0x7, 0x8,
    0x7, 0x8, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9,
    0x8, 0x9, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9,
    0x9, 0xa, 0x9, 0xa, 0x9, 0xa, 0x9, 0xa,
    0x9, 0xa, 0x9, 0xa, 0xa, 0xb, 0xa, 0xb,
    0xa, 0xb, 0xa, 0xb, 0xa, 0xb, 0xa, 0xb,
    0xa, 0xb, 0xb, 0xff, 0xb, 0xff, 0xb, 0xff
};

// Аналогично предыдущому, только тут хранятся относительные расстояния до этих нот
const float tones_cfs[MAXN] = {
    0, 0, 0, 0.192376,
    0, 0.384751, 0, 0.577127,
    0, 0.769502, 0, 0.961878,
    0.972459, 0.970609, 0.991232, 0.952231,
    0.973552, 0.969531, 0.971351, 0.97172,
    0.981273, 0.961901, 0.945098, 0.998684,
    0.972438, 0.970629, 0.951009, 0.992491,
    0.991232, 0.952231, 0.980154, 0.962984,
    0.973536, 0.969531, 0.970754, 0.9723,
    0.971351, 0.97172, 0.97494, 0.96813,
    0.981273, 0.96189, 0.990114, 0.9533,
    0.945109, 0.998695, 0.957771, 0.985485,
    0.972448, 0.97062, 0.989059, 0.954319,
    0.951018, 0.992491, 0.970248, 0.972816,
    0.991232, 0.952223, 0.957051, 0.986231,
    0.980162, 0.962977, 0.948544, 0.995076,
    0.973544, 0.969524, 0.944042, 0.999822,
    0.970761, 0.972307, 0.999097, 0.944728,
    0.971344, 0.97172, 0.945091, 0.998712,
    0.97494, 0.968137, 0.949941, 0.993614,
    0.981266, 0.96189, 0.957333, 0.985937,
    0.990115, 0.9533, 0.967089, 0.975998,
    0.945109, 0.998695, 0.979055, 0.964067,
    0.957771, 0.985491, 0.993133, 0.950398,
    0.972443, 0.970619, 0.952597, 0.99084,
    0.989059, 0.954318, 0.969666, 0.973405,
    0.951019, 0.992491, 0.988555, 0.9548,
    0.970249, 0.972815, 0.952608, 0.99083,
    0.991232, 0.952223, 0.973842, 0.969227,
    0.957052, 0.986231, 0.996776, 0.946927,
    0.980163, 0.962976, 0.964095, 0.979026,
    0.948545, 0.995075, 0.988997, 0.954375,
    0.973544, 0.969523, 0.958567, 0.984672,
    0.944043, 0.999821, 0.985251, 0.958004,
    0.970762, 0.972303, 0.956693, 0.986601,
    0.999101, 0.944724, 0.985029, 0.95822,
    0.971348, 0.971716, 0.958042, 0.985212,
    0.945095, 0.998708, 0.987943, 0.955395,
    0.974943, 0.968133, 0.962282, 0.980872,
    0.949945, 0.99361, 0.993691, 0.949866,
    0.98127, 0.961889, 0.969156, 0.973913,
    0.957337, 0.985936, 0.945803, 0.99796,
    0.990115, 0.9533, 0.978467, 0.964648,
    0.967089, 0.975997, 0.955973, 0.987346,
    0.94511, 0.998695, 0.990056, 0.953355,
    0.979056, 0.964066, 0.968297, 0.974778,
    0.957772, 0.98549, 0.947473, 0.996202,
    0.993134, 0.9504, 0.98268, 0.960511,
    0.972443, 0.970621, 0.962418, 0.980732,
    0.952598, 0.990843, 0.999048, 0.944772,
    0.989057, 0.954315, 0.979265, 0.963859,
    0.969664, 0.973402, 0.96025, 0.982945,
    0.951017, 0.992488, 0.997973, 0.945792,
    0.988558, 0.9548, 0.979319, 0.963807,
    0.970252, 0.972815, 0.96135, 0.981822,
    0.952611, 0.99083, 0.944028, 0.999837,
    0.991233, 0.952222, 0.982461, 0.960724,
    0.973843, 0.969226, 0.965374, 0.977728,
    0.957052, 0.98623, 0.948872, 0.994732,
    0.996776, 0.946928, 0.9884, 0.954953,
    0.980163, 0.962978, 0.972063, 0.971003,
    0.964095, 0.979027, 0.956257, 0.987052,
    0.948545, 0.995077, 0.996908, 0,
    0.988996, 0, 0.981209, 0
};

// Структура для хранения комплексных чисел
typedef struct{
    float re, im;
} cmpx;

// Массив отсчётов
cmpx arr[MAXN];
// Количество уже снятых отсчётов
volatile short cnt = 0;

// АЦП
void ADC_init(){
// ADMUX
    // REFS1 REFS0 = 01 - опорное напряжение - это AVCC
    ADMUX |= (1 << REFS0);
    // MUX = 0000 - канал для входного сигнала ADC0

    // 8 старших битов после преобразования кладём в ADCH
    ADMUX |= (1 << ADLAR);

// ADCSR
    // Предделитель = 128, f = fmk / pred Hz
    ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);

    // Разрешаем первый запуск
    ADCSRA |= (1 << ADSC);

    // Активация прерывания
    ADCSRA |= (1 << ADIE);

    // Прерывание при совпадении с регистром сравнения A таймера 0
    ADCSRB |= (1 << ADTS1) | (1 << ADTS0);

    // Включение автоматического запуска АЦП
    ADCSRA |= (1 << ADATE);

    // Включаем ADC
    ADCSRA |= (1 << ADEN);
}

// ТАЙМЕР 0
void timer_0_init(){
// TCNT0
    TCNT0 = 0;

// OCR0A
    // Устанавливаем в регистр сравнения нужное значение, тогда fd = fmk / (pred * (OCR0A + 1))
    OCR0A = 76;

// TIMSK0
    // Разрешаем прерывания и прерывания по совпадению с OCR0A
    TIMSK0 |= (1 << TOIE0) | (1 << OCIE0A);

// TCCR0
    // Устанавливаем режим сброса таймера по совпадению с OCR0A
    TCCR0A |= (1 << WGM01);

    // Устанавливаем предделитель = 256
    TCCR0B |= (1 << CS02); //(1 << CS01) | (1 << CS00);
}

/*void USART_Init( unsigned int ubrr)
{
    //Set baud rate
    UBRR0H = (unsigned char)(ubrr>>8);
    UBRR0L = (unsigned char)ubrr;
    // Enable receiver and transmitter
    UCSR0B = (1<<TXEN0);
    // Set frame format: 8data, 2stop bit
    UCSR0C = (1<<USBS0)|(3<<UCSZ00);
}*/

/*void USART_Transmit( unsigned char data )
{
    // Wait for empty transmit buffer
    while ( !( UCSR0A & (1<<5)) ); // 5 == UDRE
    // Put data into buffer, sends the data
    UDR0 = data;
}*/

short k, k_half, ndk, i, j, t;
short cfs_i, y;
short ober;
cmpx first, w, cf;
// Массивы амплитудных пиков и индексов их частот в спектре
float picks[PICKS];
short picks_ind[PICKS];
// Массив для суммарному вкладу каждого пика в каждую ноту
float sum_amp[12];
float amp, prev_amp, next_amp;
float f_note, f_t, dist;
// Массивы для преобразования номера ноты в её символьное обозначение
const char note[13] =      "CCDDEFFGGAAB";
const char note_sign[13] = " # #  # # # ";
// Строка результата
char res[17] = "                ";

// "Бабочка" для БПФ
void butterfly(){
    first = arr[j];
    cf.re = cfs[cfs_i];
    cf.im = cfs[cfs_i + 1];

    w.re = cf.re * arr[y].re - cf.im * arr[y].im;
    w.im = cf.re * arr[y].im + cf.im * arr[y].re;

    arr[j].re = arr[j].re + w.re;
    arr[j].im = arr[j].im + w.im;

    arr[y].re = first.re - w.re;
    arr[y].im = first.im - w.im;
}

void fft_less_memory(){
    // БПФ
    for (k = 2; k <= MAXN; k <<= 1){
        k_half = k >> 1;
        ndk = MAXN / k;
        for (i = 0; i < MAXN; i += k){
            for (j = i, t = 0; j < i + k_half; ++j, t += ndk){
                cfs_i = t << 1;
                y = j + k_half;
                butterfly();
            }
        }
    }
}

// Функция обработки измерений
void data_processing(){
    fft_less_memory();

    // Обнуление массивов после предыдущих рассчётов
    for (i = 0; i < PICKS; ++i){
        picks[i] = 0;
        picks_ind[i] = 0;
    }

    for (i = 0; i < 12; ++i){
        sum_amp[i] = 0;
    }

    // Находим пики
    // Поддерживаем квадраты амплитуд трёх подряд идущих частот спектра
    prev_amp = arr[3].re * arr[3].re + arr[3].im * arr[3].im;
    amp = arr[4].re * arr[4].re + arr[4].im * arr[4].im;
    for (i = 5; i < MAXN / 2; ++i){
        next_amp = arr[i].re * arr[i].re + arr[i].im * arr[i].im;
        // Если амплитуда - пик и больше, чем самая низкая из 6 уже найденных максимальных
        if (prev_amp <= amp && amp > next_amp && amp > picks[0]){
            /*
               Заменяем нулевой пик этой амплитудой и двигаем её вправо по массиву
               до тех пор, пока он снова не станет отсортированным
            */
            picks[0] = amp;
            picks_ind[0] = i - 1;
            for (j = 1; j < PICKS && picks[j] < picks[j - 1]; ++j){
                prev_amp = picks[j];
                picks[j] = picks[j - 1];
                picks[j - 1] = prev_amp;

                t = picks_ind[j];
                picks_ind[j] = picks_ind[j - 1];
                picks_ind[j - 1] = t;
            }
        }
        prev_amp = amp;
        amp = next_amp;
    }

    // Считаем суммарную амплитуду для нот по пикам
    for (i = 0; i < PICKS; ++i){
        picks[i] = sqrt(picks[i]);
        j = picks_ind[i] << 1;
        // Если частота пика достаточно высокая
        if (picks_ind[i] >= 20){
            /*
               Смотрим к какой ноте он ближе (к левой или правой)
               и учитываем его только в её амплитуде и в амплитуде её обертона
            */
            if (tones_cfs[j] > tones_cfs[j + 1]){
                sum_amp[tones[j]] += picks[i] * tones_cfs[j];
                sum_amp[tones[(j - 7 + 12) % 12]] += picks[i] * tones_cfs[j] * 0.4;
            }
            else{
                sum_amp[tones[j + 1]] += picks[i] * tones_cfs[j + 1];
                sum_amp[tones[(j + 1 - 7 + 12) % 12]] += picks[i] * tones_cfs[j + 1] * 0.4;
            }
        }
        else{
            // Иначе учитываем пик для обеих нот
            sum_amp[tones[j]] += picks[i] * tones_cfs[j];
            sum_amp[tones[j + 1]] += picks[i] * tones_cfs[j + 1];
        }
    }

    // Основной тон будет максимальным по амплитуде
    j = 0;
    for (i = 1; i < 12; ++i){
        if (sum_amp[i] > sum_amp[j]){
            j = i;
        }
    }
    // Преобразуем номер ноты в символьное представление
    res[0] = note[j];
    res[1] = note_sign[j];
    //USART_Transmit((unsigned char)j);
    //USART_Transmit(' ');

    // Находим самый высокий обертон основного тона и самый близкий к правильному звучанию
    k = 0;
    ober = (j + 7) % 12;
    dist = 0;
    for (i = 0; i < PICKS; ++i){
        t = picks_ind[i] << 1;
        if (picks_ind[i] >= 20){
            if ((tones[t] == j || tones[t] == ober) && tones_cfs[t] >= dist){
                k = t;
                dist = tones_cfs[t];
            }
            else if((tones[t + 1] == j || tones[t + 1] == ober) && tones_cfs[t + 1] >= dist){
                k = t + 1;
                dist = tones_cfs[t + 1];
            }
        }
    }

    // Определяем индексы частот в нашей шкале между которыми лежит обертон или сама нота
    j = k - 1;
    if (k % 2 != 0){
        j = k;
        k = k + 1;
    }

    // Вычисляем амплитуды соседних частот
    t = k >> 1;
    amp = sqrt(arr[t].re * arr[t].re + arr[t].im * arr[t].im);
    prev_amp = sqrt(arr[t - 1].re * arr[t - 1].re + arr[t - 1].im * arr[t - 1].im);

    // Находим их центр масс
    f_t = f_step * t;
    f_note = f_t - f_t * (1 - tones_cfs[k]);

    dist = f_t - f_step * prev_amp / (amp + prev_amp);

    // Определяем насколько он близок к нужной частоте и в каком направлении
    if (dist >= f_note){
        dist = (dist - f_note) / dist;
        res[3] = '-';
    }
    else{
        dist = (f_note - dist) / f_note;
        res[3] = '+';
    }
    // Преобразуем расстояние в условные единицы
    t = (short)(dist * 1000) / 2 % 100;

    // Записываем результат в строку
    res[4] = t / 10 + '0';
    res[5] = t % 10 + '0';
    if (res[0] == 'A' && res[1] == '#'){
        res[0] = 'A';
    }
    // Выводим строку результата на дисплей
    lcdGotoXY(0, 0);
    lcdPuts(res);
    //USART_Transmit((unsigned char)(dist * 1000));
    //USART_Transmit(' ');

    // Обнуляем счётчик отсчётов
    cnt = 0;
}

int main()
{
    // Разрешаем прерывания
    sei();
    _delay_ms(100);
    // Инициализируем дисплей
    lcdInit();
    lcdSetDisplay(LCD_DISPLAY_ON);
    lcdSetCursor(LCD_CURSOR_OFF);

    //USART_Init(MYUBRR);
    // Инициализируем АЦП
    ADC_init();
    // Инициализируем Таймер 0
    timer_0_init();
    // Запускаем бесконечный цикл
    for(; 1;){
    }
    return 0;
}

// Обработчик прерывания АЦП
ISR(ADC_vect){
    //ADCBUF[cnt + MAXN] = ADCH;
    /*
       Результат преобразования умножаем на оконную функцию и записываем
        на нужную для БПФ позицию в массив отсчётов
    */
    arr[pos[cnt]].re = (float)ADCH * window[cnt];
    // Обнуляем мнимую часть
    arr[pos[cnt]].im = 0;

    // Увеличиваем счётчик отсчётов
    cnt += 1;

    // Проверяем, сняли ли мы нужное количество измерений
    if (cnt == MAXN){
        // Вызываем обработчик измерений
        data_processing();
    }
}

ISR (TIMER0_COMPA_vect){
}
